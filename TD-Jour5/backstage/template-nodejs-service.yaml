# Software Template - Golden Path pour microservice Node.js
# Ce template génère un nouveau microservice avec toutes les bonnes pratiques intégrées
apiVersion: scaffolder.backstage.io/v1beta3
kind: Template
metadata:
  name: nodejs-microservice-template
  title: Node.js Microservice (Golden Path)
  description: |
    Crée un nouveau microservice Node.js/Express avec :
    - Dockerfile multi-stage sécurisé (non-root)
    - Health checks (liveness + readiness)
    - Métriques Prometheus (prom-client)
    - Logging structuré (winston)
    - Manifest Kubernetes complet
    - catalog-info.yaml pour Backstage
  tags:
    - nodejs
    - express
    - recommended
    - golden-path
spec:
  owner: team-platform
  type: service

  # Paramètres demandés à l'utilisateur
  parameters:
    - title: Informations du Service
      required:
        - serviceName
        - description
        - owner
      properties:
        serviceName:
          title: Nom du Service
          type: string
          description: Nom unique du microservice (ex. inventory-service)
          pattern: '^[a-z0-9-]+$'
          ui:autofocus: true
        description:
          title: Description
          type: string
          description: Description courte du service
        owner:
          title: Équipe Propriétaire
          type: string
          description: Équipe responsable du service
          enum:
            - team-frontend
            - team-backend
            - team-payments
            - team-platform
          enumNames:
            - Frontend Team
            - Backend Team
            - Payments Team
            - Platform Team

    - title: Configuration Technique
      properties:
        port:
          title: Port HTTP
          type: integer
          default: 8080
          description: Port sur lequel le service écoute
        replicas:
          title: Nombre de Replicas
          type: integer
          default: 2
          minimum: 1
          maximum: 10
          description: Nombre de pods en production
        criticality:
          title: Criticité
          type: string
          default: medium
          enum:
            - low
            - medium
            - high
          description: Niveau de criticité (impact sur SLOs et alerting)

  # Étapes d'exécution du template
  steps:
    # Étape 1: Générer les fichiers à partir du skeleton
    - id: fetch-skeleton
      name: Générer la structure du projet
      action: fetch:template
      input:
        url: https://github.com/BCayroche-ff/Dev-Docker-TD2/tree/TD-J5/TD-Jour5/backstage/skeleton
        values:
          serviceName: ${{ parameters.serviceName }}
          description: ${{ parameters.description }}
          owner: ${{ parameters.owner }}
          port: ${{ parameters.port }}
          replicas: ${{ parameters.replicas }}
          criticality: ${{ parameters.criticality }}

    # Étape 2: Log des fichiers générés (pour le TP)
    - id: log-result
      name: Afficher le résultat
      action: debug:log
      input:
        message: "Service ${{ parameters.serviceName }} généré avec succès !"
        listWorkspace: true

  # Sorties affichées à l'utilisateur
  output:
    links:
      - title: Documentation Backstage
        url: https://backstage.io/docs
    text:
      - title: Fichiers générés
        content: |
          Le service **${{ parameters.serviceName }}** a été généré avec :
          - package.json
          - server.js (Express avec health checks)
          - Dockerfile (multi-stage, non-root)
          - catalog-info.yaml
          - k8s/deployment.yaml

          En production, ces fichiers seraient publiés sur GitHub automatiquement.

---
# Exemple de structure skeleton (normalement dans un dossier séparé)
# Ce fichier montre ce que le template génère
# En réalité, le dossier skeleton/ contiendrait ces fichiers en tant que templates

# Fichiers générés par le template:
#
# skeleton/
# ├── package.json
# ├── server.js
# ├── Dockerfile
# ├── catalog-info.yaml
# └── k8s/
#     └── deployment.yaml
#
# Chaque fichier utilise les variables ${{ values.serviceName }}, etc.
