# Task: Cosign Sign
# Signe une image Docker avec Cosign (Sigstore)
# La signature est stockée dans le registry avec l'image
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: cosign-sign
  namespace: tekton-pipelines
  labels:
    app.kubernetes.io/part-of: tekton-tasks
  annotations:
    tekton.dev/displayName: "Cosign Sign Image"
    tekton.dev/categories: "Security"
    tekton.dev/tags: "security, signing, cosign, sigstore"
spec:
  description: |
    Signe une image Docker avec Cosign.
    Utilise la signature keyless (OIDC) par défaut.
    La signature est stockée dans Rekor (log de transparence).

  params:
    - name: IMAGE
      description: Image à signer (registry/repo:tag ou digest)
      type: string
    - name: SIGNING_TYPE
      description: Type de signature (keyless ou key)
      type: string
      default: "keyless"
    - name: ANNOTATIONS
      description: Annotations à ajouter à la signature
      type: array
      default: []

  workspaces:
    - name: cosign-keys
      description: Workspace contenant les clés Cosign (si signing_type=key)
      optional: true

  results:
    - name: SIGNATURE
      description: URL de la signature
    - name: SIGNED
      description: Image signée (true/false)

  steps:
    - name: sign
      image: gcr.io/projectsigstore/cosign:latest
      script: |
        #!/bin/sh
        set -e

        IMAGE="$(params.IMAGE)"
        echo "Signing image: $IMAGE"
        echo "Signing type: $(params.SIGNING_TYPE)"

        if [ "$(params.SIGNING_TYPE)" = "keyless" ]; then
          # Signature keyless (OIDC)
          # Note: Nécessite une session OIDC interactive en production
          # Pour le TP, on simule le comportement
          echo "Keyless signing requires interactive OIDC authentication."
          echo "In a real CI/CD environment, this would use workload identity."
          echo ""
          echo "Command that would be executed:"
          echo "cosign sign --yes $IMAGE"
          echo ""
          echo "For this TP, we'll skip the actual signing."
          echo -n "skipped-for-tp" > $(results.SIGNATURE.path)
          echo -n "false" > $(results.SIGNED.path)

        elif [ "$(params.SIGNING_TYPE)" = "key" ]; then
          # Signature avec clé privée
          if [ -f "$(workspaces.cosign-keys.path)/cosign.key" ]; then
            export COSIGN_PASSWORD=""
            cosign sign --key $(workspaces.cosign-keys.path)/cosign.key $IMAGE
            echo -n "signed-with-key" > $(results.SIGNATURE.path)
            echo -n "true" > $(results.SIGNED.path)
            echo "Image signed successfully with key"
          else
            echo "ERROR: cosign.key not found in workspace"
            exit 1
          fi
        else
          echo "ERROR: Unknown signing type: $(params.SIGNING_TYPE)"
          exit 1
        fi

    - name: verify
      image: gcr.io/projectsigstore/cosign:latest
      script: |
        #!/bin/sh
        # Vérification optionnelle après signature
        echo "Signature status: $(cat $(results.SIGNED.path))"
        if [ "$(cat $(results.SIGNED.path))" = "true" ]; then
          echo "Verifying signature..."
          # cosign verify $(params.IMAGE)
          echo "Signature verified"
        else
          echo "Skipping verification (image not signed in this run)"
        fi

---
# Note pédagogique: Cosign et Sigstore
#
# Sigstore est un projet de la Linux Foundation pour la signature de software.
# Il comprend:
# - Cosign: Outil de signature d'images
# - Rekor: Log de transparence (blockchain-like)
# - Fulcio: CA pour certificats éphémères
#
# Signature Keyless:
# 1. L'utilisateur s'authentifie via OIDC (GitHub, Google, etc.)
# 2. Fulcio génère un certificat éphémère
# 3. Cosign signe l'image avec ce certificat
# 4. La signature est enregistrée dans Rekor
#
# Avantages:
# - Pas de gestion de clés privées
# - Audit trail dans Rekor
# - Lié à l'identité (pas juste une clé)
#
# Vérification:
# cosign verify --certificate-identity=user@example.com \
#   --certificate-oidc-issuer=https://github.com/login/oauth \
#   registry/image:tag
